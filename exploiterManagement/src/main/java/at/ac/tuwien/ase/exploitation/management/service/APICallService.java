package at.ac.tuwien.ase.exploitation.management.service;

import at.ac.tuwien.ase.exploitation.management.dto.APICallDto;
import at.ac.tuwien.ase.exploitation.management.model.APICall;
import at.ac.tuwien.ase.exploitation.management.model.Exploiter;
import at.ac.tuwien.ase.exploitation.management.persistence.APICallRepository;
import at.ac.tuwien.ase.exploitation.management.persistence.ExploiterManagementRepository;
import at.ac.tuwien.ase.exploitation.management.service.exception.ExploiterNotFoundException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.protobuf.ByteString;
import com.google.pubsub.v1.PubsubMessage;
import java.nio.charset.Charset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gcp.pubsub.core.PubSubTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * @author Kevin Haller
 * @version 1.0
 * @since 1.0
 */
@Service
public class APICallService {

  private static final Logger logger = LoggerFactory.getLogger(APICreditService.class);

  @Value("${pubsub.topic.apicalls}")
  private String apiCallsTopicName;

  private ExploiterManagementRepository exploiterManagementRepository;
  private APICallRepository apiCallRepository;
  private ObjectMapper objectMapper;
  private PubSubTemplate pubSubTemplate;

  @Autowired
  public APICallService(
      ExploiterManagementRepository exploiterManagementRepository,
      APICallRepository apiCallRepository,
      ObjectMapper objectMapper,
      PubSubTemplate pubSubTemplate) {
    this.exploiterManagementRepository = exploiterManagementRepository;
    this.apiCallRepository = apiCallRepository;
    this.objectMapper = objectMapper;
    this.pubSubTemplate = pubSubTemplate;
  }

  /**
   * @param apiCallDto that shall be registered.
   */
  @Transactional(isolation = Isolation.SERIALIZABLE, propagation = Propagation.REQUIRES_NEW)
  public void registerAPICallForExploiter(APICallDto apiCallDto) {
    if (apiCallDto.getUid() == null || apiCallDto.getUid().isEmpty()) {
      throw new IllegalArgumentException("The username must be given, and not null or empty.");
    }
    logger.info("Registers given api call {}.", apiCallDto);
    Exploiter exploiter = exploiterManagementRepository
        .findFirstByUsername(apiCallDto.getUid());
    if (exploiter != null) {
      exploiter.addCredit(-apiCallDto.getCost());
      APICall apiCall = new APICall();
      apiCall.setExploiter(exploiter);
      apiCall.setCost(apiCallDto.getCost());
      apiCall.setPayload(apiCallDto.getPayload());
      apiCall.setTimestamp(apiCallDto.getTimestamp());
      try {
        pubSubTemplate.publish(apiCallsTopicName, PubsubMessage.newBuilder().setData(ByteString
            .copyFrom(objectMapper.writeValueAsString(apiCallDto), Charset.forName("utf-8")))
            .build());
      } catch (JsonProcessingException e) {
        logger.error("The api call {} could not be pushed to the pub/sub topic {}.", apiCallDto,
            apiCallsTopicName);
      }
    } else {
      throw new ExploiterNotFoundException(
          String.format("No exploiter with the username '%s' found.", apiCallDto.getUid()));
    }
  }

}
